#!/bin/bash

#### Description: Script to use phasing output to replace variants in the mnd-derived snp-mnd file.
#### Usage: bash ./replace-variants-with-homologs-in-var-mnd.sh [options] <path_to_phased_psf> <path_to_var_mnd_file>.
#### Input: psf file, snp mnd file.
#### Output: modified mnd file.
#### TODO: untested unprompted chr parameter, finalize if proves useful.
#### Dependencies: GNU Parallel [? optional].
#### Written by: Olga Dudchenko, version date 01/27/2021

USAGE="
*****************************************************
Replace variant calls with homolog calls (according to the largest phased block) in the [typically dangling_native] mnd file: 1/27/21.

USAGE: ./replace-variants-with-homologs-in-var-mnd.sh [options] <path_to_psf_file> <path_to_var_mnd_file>

DESCRIPTION:
This is a script to replace variant calls in var mnd files generated by the 3D-DNA phaser with homolog calls, in accordance with the largest phased block.

ARGUMENTS:
path_to_psf_file
						Specify path to a (typically phased, i.e. out.psf) psf file describing variant phasing.
path_to_var_mnd_file
						Specify path to a var mnd file (typically dangling/native) generated by the phaser that contains Hi-C reads overlapping variants.

OPTIONS:
-k
						Keep dangling reads. If not invoked only reads that overlap with phased variants on both R1 and R2 will be kept. 
-h
						Shows this help.
*****************************************************
"
## 3D-DNA

keep_dangling_reads=0;
chr="";

## HANDLE OPTIONS
while getopts "c:kh" opt; do
case $opt in
	h) echo "$USAGE"
		exit 0
	;;
	k)  echo "... -k flag was triggered, will keep dangling reads, i.e. reads overlapping only one SNP in the mnd." >&1
        keep_dangling_reads=1;
    ;;
    c)  chr=$OPTARG
        echo "... -c flag was triggered, ignoring all sequences in the psf except for $OPTARG." >&1
    ;;
	*)  echo ":( Illegal options. Exiting!"
		echo "$USAGE"
		exit 1
	;;
esac
done

shift $(( OPTIND-1 ))

## HANDLE ARGUMENTS

[ -z $1 ] || [ -z $2 ] && echo >&2 ":( Not sure how to parse your input: files not listed or not found at expected locations. Exiting!" && echo >&2 "$USAGE" && exit 1

[ ! -s $1 ] || [ ! -s $2 ] && echo >&2 ":( Not sure how to parse your input: files not listed or not found at expected locations. Exiting!" && echo >&2 "$USAGE" && exit 1

if [ "$#" -ne 2 ]; then
    echo >&2 "Illegal number of arguments. Please double check your input. Exiting!" && echo >&2 "$USAGE" && exit 1
fi

psf=$1
mnd=$2

outfile="homolog.mnd.txt"

export chr
export keep_dangling_reads

doit() {
	awk -v chr=${chr} -v keep_dangling=${keep_dangling_reads} -f <(cat - <<-'EOD'
BEGIN{if(length(chr)>0){split(chr,chromlist,"|"); for(i in chromlist){c[chromlist[i]]=1}}}
# read in the psf
FILENAME==ARGV[1]&&($0~/^>/){
if((!chr)||(substr($1,2) in c))
{
chr_of_origin[$NF]=substr($1,2); pos[$NF]=$2; var1[$NF]=$3; var2[$NF]=$4
var_counter[substr($1,2)]++
}
next
}
FILENAME==ARGV[1]{
if(!(chr_of_origin[$1] in var_counter)){next}
if(NF>maxlength[chr_of_origin[$1]]){
maxlength[chr_of_origin[$1]]=NF
longest[chr_of_origin[$1]]=$0
}
next
}
FNR==1{
for(i in var_counter){
n=split(longest[i],var," ")
for(j=1;j<=n;j++){
if(var[j]>0){replacement[chr_of_origin[var[j]]":"pos[var[j]]":"var1[var[j]]]=chr_of_origin[var[j]]"-r"; replacement[chr_of_origin[var[j]]":"pos[var[j]]":"var2[var[j]]]=chr_of_origin[var[j]]"-a";
}
else
{
replacement[chr_of_origin[-var[j]]":"pos[-var[j]]":"var2[-var[j]]]=chr_of_origin[-var[j]]"-r"; replacement[chr_of_origin[-var[j]]":"pos[-var[j]]":"var1[-var[j]]]=chr_of_origin[-var[j]]"-a";
}
}
}
}
# read in the mnd
{
ambiguous=0
if($2 in replacement){$2=replacement[$2]}else{if(!keep_dangling){next}; ambiguous=1}
if($6 in replacement){$6=replacement[$6]}else{if(!keep_dangling){next}; if(ambiguous){next}else{ambiguous=2}}
if(!ambiguous){
print
}else if (ambiguous==1){
split($2,a,":"); tmp=a[1]; if(chr&&!(tmp in c)){next}; $2=tmp"-r"; print; $2=tmp"-a"; print; 
}else{
split($6,a,":"); tmp=a[1]; if(chr&&!(tmp in c)){next}; $6=tmp"-r"; print; $6=tmp"-a"; print;
}
}
EOD
) $1 $2
}

export -f doit

##	GNU Parallel Dependency
parallel="false"
if hash parallel 2>/dev/null; then
        ver=`parallel --version | awk 'NR==1{print \$3}'`
        [ $ver -ge 20150322 ] && parallel="true"
fi

[ $parallel == "false" ] && echo >&2 ":| WARNING: GNU Parallel version 20150322 or later not installed. We highly recommend to install it to increase performance. Starting pipeline without parallelization!"

[ $parallel == "true" ] && parallel -a ${mnd} --pipepart -j 80% --will-cite --block 1G --env doit "doit ${psf} -" > ${outfile} || doit ${psf} ${mnd} > ${outfile}