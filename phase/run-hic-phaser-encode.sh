#!/bin/bash

{

#### Description: Wrapper script to phase genomic variants from ENCODE DCC hic-pipeline.
#### Usage: bash ./run-hic-phaser-encode.sh [options] <path_to_vcf> <path_to_aligned_dedupped_bam>.
#### Input: vcf file, bam file.
#### Output: phased vcf & hic maps.
#### Dependencies: 3D-DNA, GNU Parallel, Java.
#### Written by: Olga Dudchenko, 10/14/2021 [updated from version dates: 09/01/2021; 08/18/2020].

echo "*****************************************************" >&1
echo "cmd log: "$0" "$* >&1
echo "*****************************************************" >&1


USAGE="
*****************************************************
Phase genomic variants after ENCODE DCC hic-pipeline.

USAGE: ./run-hic-phaser-encode.sh [options] <path_to_vcf> <path_to_aligned_dedupped_bam>

DESCRIPTION:
This is a wrapper script to use 3D-DNA phaser to phase SNPs using Hi-C alignment data as generated by the ENCODE DCC hic & variant calling pipeline.

ARGUMENTS:
path_to_vcf
						Path to a Variant Call Format (vcf) file containing sequence variation data, e.g. as generated by the ENCODE DCC Hi-C variant calling pipeline.

path_to_aligned_dedupped_bam
						Path to bam file containing deduplicated alignments of Hi-C reads in bam format (output by Juicer2).

OPTIONS:
-h|--help
						Shows this help.

DATA FILTERING:						
-c|--chr [chr_list]
		                Phase only specific molecules (default phases all molecules listed in the vcf file).

-q|--mapq [mapq]
		                Consider only Hi-C reads that align with minimal mapping quality of mapq (default is 1).

PHASER CONTROL:
-s|--stringency [stringency]
		                Specify stringency parameter for the phaser (default is 3, i.e. 3-fold enrichment in Hi-C signal to one molecule as compared to the other is necessary to phase).

-b|--background [background]
		                Specify background parameter for the phaser (default is 1, i.e. calculate enrichment on top of the noise level of 1 read)

-v|--verbose [step_for_intermediate_data_dump]
						Print intermediate phasing results every [step_for_intermediate_data_dump] steps.

WORKFLOW CONTROL:
-t|--threads [num]
        				Indicate how many threads to use. Default: half of available cores as calculated by parallel --number-of-cores.

--from-stage [pipeline_stage]
						Fast-forward to a particular stage of the pipeline. The pipeline_stage argument can be \"prep\", \"sort\", \"recalibrate_bases\", \"genotype\", \"recalibrate_variants\", \"cleanup\". 

--to-stage [pipeline_stage]
						Exit after a particular stage of the pipeline. The argument can be \"prep\", \"sort\", \"recalibrate_bases\", \"genotype\", \"recalibrate_variants\", \"cleanup\".

*****************************************************
"

# path to 3D-DNA pipeline
pipeline=`cd "$( dirname $0)" && cd .. && pwd`

# defaults:
chr=""
mapq=1
stringency=3
background=1
verbose=""

#multithreading
threads=`parallel --number-of-cores`
threads=$((threads/2))
# adjust for mem usage
tmp=`awk '/MemTotal/ {threads=int($2/1024/1024/2/6-1)}END{print threads+0}' /proc/meminfo 2>/dev/null`
tmp=$((tmp+0))
([ $tmp -gt 0 ] && [ $tmp -lt $threads ]) && threads=$tmp

#staging
first_stage="prep_bam"
last_stage="map_diploid"
declare -A stage
stage[prep_bam]=0
stage[parse_vcf]=1
stage[parse_bam]=2
stage[visualize_input]=3
stage[phase]=4
stage[visualize_output]=5
stage[update_vcf]=6
stage[map_diploid]=7
#stage[cleanup]=8

############### HANDLE OPTIONS ###############

while :; do
	case $1 in
		-h|--help)
			echo "$USAGE" >&1
			exit 0
        ;;
### data filtration
        -c|--chr) OPTARG=$2
			echo "... -c|--chr flag was triggered, ignoring all sequences in the vcf except for $OPTARG." >&1
			chr=$OPTARG
        	shift
        ;;
        -q|--mapq) OPTARG=$2
			re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
				echo "... -q|--mapq flag was triggered, phasing using reads with at least $OPTARG mapping quality." >&1
				mapq=$OPTARG
			else
				echo ":( Wrong syntax for mapping quality parameter. Exiting!" >&2
				exit 1
			fi
        	shift
        ;;
### phaser
        -s|--stringency) OPTARG=$2
			re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
				echo "... -s|--stringency flag was triggered, phasing requiring at least $OPTARG enrichment of one haplotype vs the other." >&1
				stringency=$OPTARG
			else
				echo ":( Wrong syntax for stringency parameter. Exiting!" >&2
				exit 1
			fi
        	shift
        ;;
        -b|--background) OPTARG=$2
			re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
				echo "... -b|--background flag was triggered, phasing requiring enrichment against $OPTARG read(s) background noise." >&1
				background=$OPTARG
			else
				echo ":( Wrong syntax for background parameter. Exiting!" >&2
				exit 1
			fi
        	shift
        ;;
		-v|--verbose) OPTARG=$2
			verbose=$OPTARG
			shift
		;;
### workflow	
        -t|--threads) OPTARG=$2
        	re='^[0-9]+$'
			if [[ $OPTARG =~ $re ]]; then
					echo " -t|--threads flag was triggered, will try to parallelize across $OPTARG threads." >&1
					threads=$OPTARG
			else
					echo " :( Wrong syntax for thread count parameter value. Exiting!" >&2
					exit 1
			fi        	
        	shift
        ;;	
		--from-stage) OPTARG=$2
			if [ "$OPTARG" == "parse_vcf" ] || [ "$OPTARG" == "parse_bam" ] || [ "$OPTARG" == "visualize_input" ] || [ "$OPTARG" == "phase" ] || [ "$OPTARG" == "visualize_output" ] || [ "$OPTARG" == "update_vcf" ] || [ "$OPTARG" == "map_diploid" ]; then
        		echo " --from-stage flag was triggered. Will fast-forward to $OPTARG." >&1
        		first_stage=$OPTARG
			else
				echo " :( Whong syntax for pipeline stage. Please use parse_vcf/parse_bam/visualize_input/phase/visualize_output/update_vcf/map_diploid. Exiting!" >&2
				exit 1
			fi
			shift
        ;;
		--to-stage) OPTARG=$2
			if [ "$OPTARG" == "parse_vcf" ] || [ "$OPTARG" == "parse_bam" ] || [ "$OPTARG" == "visualize_input" ] || [ "$OPTARG" == "phase" ] || [ "$OPTARG" == "visualize_output" ] || [ "$OPTARG" == "update_vcf" ] || [ "$OPTARG" == "map_diploid" ]; then
				echo " --to-stage flag was triggered. Will exit after $OPTARG." >&1
				last_stage=$OPTARG
			else
				echo " :( Whong syntax for pipeline stage. Please use parse_vcf/parse_bam/visualize_input/phase/visualize_output/update_vcf/map_diploid. Exiting!" >&2
				exit 1			
			fi
			shift
		;;
### utilitarian
        --) # End of all options
			shift
			break
		;;
		-?*)
			echo ":| WARNING: Unknown option. Ignoring: ${1}" >&2
		;;
		*) # Default case: If no more options then break out of the loop.
			break
	esac
	shift
done

if [[ "${stage[$first_stage]}" -gt "${stage[$last_stage]}" ]]; then
	echo >&2 ":( Please make sure that the first stage requested is in fact an earlier stage of the pipeline to the one requested as last. Exiting!"
	exit 1
fi

############### HANDLE EXTERNAL DEPENDENCIES ###############

##	Java Dependency
type java >/dev/null 2>&1 || { echo >&2 ":( Java is not available, please install/add to path Java. Exiting!"; exit 1; }

##	GNU Parallel Dependency
type parallel >/dev/null 2>&1 || { echo >&2 ":( GNU Parallel support is set to true (default) but GNU Parallel is not in the path. Please install GNU Parallel or set -p option to false. Exiting!"; exit 1; }
[ $(parallel --version | awk 'NR==1{print \$3}') -ge 20150322 ] && { echo >&2 ":( Outdated version of GNU Parallel is installed. Please install/add to path v 20150322 or later. Exiting!"; exit 1; }

## Samtools Dependency
type samtools >/dev/null 2>&1 || { echo >&2 ":( Samtools are not available, please install/add to path. Exiting!"; exit 1; }
ver=`samtools --version | awk 'NR==1{print \$NF}'`
[[ $(echo "$ver < 1.13" |bc -l) -eq 1 ]] && { echo >&2 ":( Outdated version of samtools is installed. Please install/add to path v 1.13 or later. Exiting!"; exit 1; }

############### HANDLE ARGUMENTS ###############

[ -z $1 ] || [ -z $2 ] && echo >&2 ":( Not sure how to parse your input: files not listed or not found at expected locations. Exiting!" && echo >&2 "$USAGE" && exit 1

[ ! -s $1 ] || [ ! -s $2 ] && echo >&2 ":( Not sure how to parse your input: files not listed or not found at expected locations. Exiting!" && echo >&2 "$USAGE" && exit 1

if [ "$#" -ne 2 ]; then
    echo >&2 "Illegal number of arguments. Please double check your input. Exiting!" && echo >&2 "$USAGE" && exit 1
fi

vcf=$1
bam=$2

##TODO: check that reference names do not contain the \":\" character

############### MAIN #################

## 0. PREP BAM FILE

if [ "$first_stage" == "parse_vcf" ]; then

	echo "...Extracting unique paired alignments from bam and sorting..." >&1

	samtools view -u -d "rt:0" -d "rt:1" -d "rt:2" -d "rt:3" -d "rt:4" -d "rt:5" -@ $((threads * 2)) -F 0x400 -q $mapq $bam |  samtools sort -@ $threads -m 6G -o reads.sorted.bam
	[ $? -eq 0 ] || { echo ":( Failed at bam sorting. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }

	samtools index -@ $threads reads.sorted.bam	
	[ $? -eq 0 ] || { echo ":( Failed at bam indexing. See err stream for more info. Exiting!" | tee -a /dev/stderr && exit 1; }		
	# e.g. will fail with chr longer than ~500Mb. Use samtools index -c -m 14 reads.sorted.bam

	echo ":) Done extracting unique paired alignments from bam and sorting." >&1

else

	([ -f reads.sorted.bam ] && [ -f reads.sorted.bam.bai ]) || { echo ":( Files from previous stages of the pipeline appear to be missing. Exiting!" | tee -a /dev/stderr; exit 1; }

fi

## I. PARSE VCF FILE [ASSUMES THE VCF FILE IS SORTED]

if [ "$first_stage" == "parse_vcf" ]; then

	echo "...Parsing vcf file..." >&1
	
	awk -v chr=${chr} -v output_prefix="in" -f ${pipeline}/phase/vcf-to-psf-and-assembly.awk ${vcf}
	mv "in.assembly" `basename ${vcf} .vcf`".in.assembly"

	assembly=`basename ${vcf} .vcf`".in.assembly"
	psf="in.psf"

	if [ -z "$chr" ]; then
		chr=$(awk '$0~/^>/{if($1!=prev){str=str"|"substr($1,2); prev=$1;}}END{print substr(str,2)}' ${psf})
	fi

	echo ":) Done parsing vcf file." >&1

	[ "$last_stage" == "parse_vcf" ] && { echo "Done with the requested workflow. Exiting after parsing vcf!"; exit; }
	first_stage="parse_bam"

else

	psf="in.psf"

	if [ ! -f $psf ] || [ ! -f `basename ${vcf} .vcf`".in.assembly" ]; then
		echo ":( Files from previous stages of the pipeline appear to be missing. Exiting!" | tee -a /dev/stderr
		exit 1
	fi

	if [ -z "$chr" ]; then
		chr=$(awk '$0~/^>/{if($1!=prev){str=str"|"substr($1,2); prev=$1;}}END{print substr(str,2)}' ${psf})
	fi

fi

## II. PARSE BAM FILE FOR READS OVERLAPPING SNPs.
if [ "$first_stage" == "parse_bam" ]; then
	
	echo "...Parsing bam file..." >&1

	if [ ! -z "$chr" ] && [[ $chr != *"|"* ]]; then
		samtools view -@ $threads reads.sorted.bam $chr | awk -f ${pipeline}/phase/extract-SNP-reads-from-sam-file.awk ${psf} - > dangling.sam

		[ ${PIPESTATUS[0]} -ne 0 ] && { echo ":( Something went wrong. Check stderr for more info. Exiting!" | tee -a /dev/stderr && exit 1; }
		## TODO: parallelize single-chrom workflow based on interval_list
	
	else
		export SHELL=$(type -p bash)
		export psf=${psf}
		export pipeline=${pipeline}
		doit () { 
			samtools view -@ 2 reads.sorted.bam $1 | awk -f ${pipeline}/phase/extract-SNP-reads-from-sam-file.awk ${psf} -
		}
		export -f doit
		echo $chr | tr "|" "\n" | parallel -j $threads --will-cite --joblog temp.log doit > dangling.sam
		exitval=`awk 'NR>1{if($7!=0){c=1; exit}}END{print c+0}' temp.log`
		[ $exitval -eq 0 ] || { echo ":( Pipeline failed at parsing bam. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
		rm temp.log
	fi

	awk '{c[$1]++}END{for (i in c){if(c[i]==2){print i}}}' dangling.sam | awk 'FILENAME==ARGV[1]{remember[$1]=1;next}($1 in remember){str[$1]=str[$1]" "$3}END{for(i in str){split(substr(str[i],2),a," "); print 0,a[1],1,0,0,a[2],1,1,1,"-","-",1,"-","-"}}' - dangling.sam > snp.mnd.txt
	edge_mnd="snp.mnd.txt"

	echo ":) Done parsing bam file." >&1

	[ "$last_stage" == "parse_bam" ] && { echo "Done with the requested workflow. Exiting after parsing bam!"; exit; }
	first_stage="visualize_input"

else
	edge_mnd="snp.mnd.txt"

	if [ ! -f ${edge_mnd}} ] || [ ! -f "dangling.sam" ]; then
		echo ":( Files from previous stages of the pipeline appear to be missing. Exiting!" | tee -a /dev/stderr
		exit 1
	fi
fi

## III. VISUALIZE INPUT PHASED BLOCKS.
if [ "$first_stage" == "visualize_input" ]; then

	echo "...Visualizing input phased blocks..." >&1

	{ bash ${pipeline}/visualize/run-assembly-visualizer.sh -c `basename ${vcf} .vcf`".in.assembly" ${edge_mnd} | sed 's/^/.../'; } 2> >(while read line; do echo "...$line" >&2; done)
 	[ ${PIPESTATUS[0]} -ne 0 ] && { echo ":( Something went wrong. Check stderr for more info. Exiting!" | tee -a /dev/stderr && exit 1; }

	echo ":) Done visualizing input phased blocks." >&1
	
	[ "$last_stage" == "visualize_input" ] && { echo "Done with the requested workflow. Exiting after visualizing input phased blocks!"; exit; }
	first_stage="phase"
fi

## IV. PHASE!

if [ "$first_stage" == "phase" ]; then

	echo "...Phasing..."
	if [ ! -z "$chr" ] && [[ $chr != *"|"* ]]; then
		{ awk -v stringency=${stringency} -v background=${background} -v outfile="out.psf" -v verbose=${verbose} -f ${pipeline}/phase/phase-intrachromosomal.awk ${psf} ${edge_mnd} | sed 's/^/.../';  } 2> >(while read line; do echo "...$line" >&2; done)
		[ ${PIPESTATUS[0]} -ne 0 ] && { echo ":( Something went wrong. Check stderr for more info. Exiting!" | tee -a /dev/stderr && exit 1; }
	else
		export SHELL=$(type -p bash)
		export psf=${psf}
		export edge_mnd=${edge_mnd}
		export stringency=${stringency}
		export background=${background}
		export verbose=${verbose}
		export pipeline=${pipeline}
		doit () { 
			cmd="echo \"Phasing chr $1.\" && awk -v chr=$1 '\$1==\">\"chr{print; id[\$NF]=1; id[-\$NF]=1}\$1~/^>/{next}(\$1 in id){print}' ${psf} > h.$1.psf && awk -v stringency=${stringency} -v background=${background} -v outfile=out.$1.psf -v verbose=${verbose} -f ${pipeline}/phase/phase-intrachromosomal.awk h.$1.psf ${edge_mnd} && rm h.$1.psf"
			eval $cmd
		}
		export -f doit
		echo $chr | tr "|" "\n" | parallel -j $threads --will-cite --joblog temp.log doit
		exitval=`awk 'NR>1{if($7!=0){c=1; exit}}END{print c+0}' temp.log`
		[ $exitval -eq 0 ] || { echo ":( Pipeline failed at phasing. See err stream for more info. Exiting! " | tee -a /dev/stderr && exit 1; }
		echo $chr | tr "|" "\n" | parallel -j $threads --will-cite -k "awk '\$0~/^>/' out.{}.psf" > out.psf
		echo $chr | tr "|" "\n" | parallel -j $threads --will-cite -k "awk '\$0!~/^>/' out.{}.psf" >> out.psf
		echo $chr | tr "|" "\n" | parallel -j $threads --will-cite rm out.{}.psf
	fi

	#TODO: exit code tracking?
	echo ":) Done phasing."

	[ "$last_stage" == "phase" ] && { echo "Done with the requested workflow. Exiting after phasing!"; exit; }
	first_stage="visualize_output"

else
	[ -f out.psf ] || { echo ":( Files from previous stages of the pipeline appear to be missing. Exiting!" | tee -a /dev/stderr; exit 1; }
fi

## V. VISUALIZE OUTPUT PHASED BLOCKS.
if [ "$first_stage" == "visualize_output" ]; then

	echo "...Visualizing output phased blocks..." >&1

	awk -f ${pipeline}/phase/psf-to-assembly.awk "out.psf" > `basename ${vcf} .vcf`".out.assembly" 

	{ bash ${pipeline}/visualize/run-assembly-visualizer.sh -c `basename ${vcf} .vcf`".out.assembly" ${edge_mnd} | sed 's/^/.../'; } 2> >(while read line; do echo "...$line" >&2; done)
 	[ ${PIPESTATUS[0]} -ne 0 ] && { echo ":( Something went wrong. Check stderr for more info. Exiting!" | tee -a /dev/stderr && exit 1; }

	echo ":) Done visualizing output phased blocks." >&1
	
	[ "$last_stage" == "visualize_output" ] && { echo "Done with the requested workflow. Exiting after visualizing output phased blocks!"; exit; }
	first_stage="update_vcf"
fi

## VI. UPDATE VCF.
if [ "$first_stage" == "update_vcf" ]; then

	echo "...Updating vcf file with phasing info..." >&1

	awk -f ${pipeline}/phase/update-vcf-using-psf.awk out.psf ${vcf} > `basename ${vcf} .vcf`"_HiC.vcf"

	echo ":) Done updating vcf file with phasing info." >&1

	[ "$last_stage" == "update_vcf" ] && { echo "Done with the requested workflow. Exiting after updating the vcf file!"; exit; }
	first_stage="map_diploid"

fi

## VII. BUILD DIPLOID MAP FROM DANGLING READS

if [ "$first_stage" == "map_diploid" ]; then

	echo "...Building diploid contact maps from reads overlapping phased SNPs..." >&1

	#-f ${juiceDir}/scripts/sam_to_pre.awk
	
	#bash ${pipeline}/phase/replace-variants-with-homologs-in-var-mnd.sh -k out.psf dangling.native.mnd.txt

	echo ":) Done building diploid contact maps from reads overlapping phased SNPs." >&1

fi

}