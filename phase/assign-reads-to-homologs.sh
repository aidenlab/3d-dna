#!/bin/bash

#### Description: Script to associate read IDs with homologs based on phasing data.
#### Usage: bash ./assign-reads-to-homologs.sh [options] <path_to_phased_psf> <path_to_dangling_sam_file>.
#### Input: psf file, dangling.sam file (sam file containing reads that overlap SNPs, with overlapping SNP concatenated to the chr field).
#### Output: tab separated table listing READ_ID and homolog (chr name with concatenated -r or -a for reference and alternative).
#### Dependencies: GNU Parallel [? optional].
#### Written by: Olga Dudchenko, original version date 01/27/2021, version 10/28/2021.

USAGE="
*****************************************************
Assign read IDs with homolog calls (according to the largest phased block) in the dangling sam file: 10/28/21.

USAGE: ./assign-reads-to-homologs.sh [options] <path_to_psf_file> <path_to_dangling_sam_file>

DESCRIPTION:
This is a script to assign read IDs to chromosomal homologs, in accordance with the largest phased block in the psf file.

ARGUMENTS:
path_to_psf_file
						Specify path to a (typically phased, i.e. out.psf) psf file describing variant phasing.
path_to_var_mnd_file
						Specify path to a var mnd file (typically dangling/native) generated by the phaser that contains Hi-C reads overlapping variants.

OPTIONS:
-c	<chromosome>		
						Only keep reads on specific sequences (e.g. chr1 or chr1|chr2|chr3). Default: all sequences present in psf. 
-t	<thread_count>
						Number of threads to use when running in parallel [Default: half of available cores as calculated by parallel --number-of-cores.]. 
-o	<outfile_name>
						Name for the output file. Default: read_to_homolog.txt
-h
						Shows this help.
*****************************************************
"

## HANDLE OPTIONS

### defaults
chr="";
threads=`parallel --number-of-cores`
threads=$((threads/2))
outfile="reads_to_homologs.txt"

while getopts "c:t:h" opt; do
case $opt in
	h) echo "$USAGE"
		exit 0
	;;
    c)  chr=$OPTARG
        echo "... -c flag was triggered, ignoring all sequences in the psf except for $OPTARG." >&1
    ;;
	t)  OPTARG=$2
        re='^[0-9]+$'
		if [[ $OPTARG =~ $re ]]; then
				echo "... -t flag was triggered, will try to parallelize across $OPTARG threads." >&1
				threads=$OPTARG
		else
				echo " :( Wrong syntax for thread count parameter value. Exiting!" >&2
				exit 1
		fi
    ;;
	*)  echo ":( Illegal options. Exiting!" >&2
		echo "$USAGE" >&1
		exit 1
	;;
esac
done

shift $(( OPTIND-1 ))

## HANDLE ARGUMENTS

[ -z $1 ] || [ -z $2 ] && echo >&2 ":( Not sure how to parse your input: files not listed or not found at expected locations. Exiting!" && echo >&2 "$USAGE" && exit 1

[ ! -s $1 ] || [ ! -s $2 ] && echo >&2 ":( Not sure how to parse your input: files not listed or not found at expected locations. Exiting!" && echo >&2 "$USAGE" && exit 1

if [ "$#" -ne 2 ]; then
    echo >&2 "Illegal number of arguments. Please double check your input. Exiting!" && echo >&2 "$USAGE" && exit 1
fi

export chr

doit() {
	awk -v chr=${chr} -f <(cat - <<-'EOD'
BEGIN{if(length(chr)>0){split(chr,chromlist,"|"); for(i in chromlist){c[chromlist[i]]=1}}}
# read in the psf
FILENAME==ARGV[1]&&($0~/^>/){
if((!chr)||(substr($1,2) in c))
{
chr_of_origin[$NF]=substr($1,2); pos[$NF]=$2; var1[$NF]=$3; var2[$NF]=$4
var_counter[substr($1,2)]++
}
next
}
FILENAME==ARGV[1]{
if(!(chr_of_origin[$1] in var_counter)){next}
if(NF>maxlength[chr_of_origin[$1]]){
maxlength[chr_of_origin[$1]]=NF
longest[chr_of_origin[$1]]=$0
}
next
}
FNR==1{
for(i in var_counter){
n=split(longest[i],var," ")
for(j=1;j<=n;j++){
if(var[j]>0){replacement[chr_of_origin[var[j]]":"pos[var[j]]":"var1[var[j]]]=chr_of_origin[var[j]]"-r"; replacement[chr_of_origin[var[j]]":"pos[var[j]]":"var2[var[j]]]=chr_of_origin[var[j]]"-a";
}
else
{
replacement[chr_of_origin[-var[j]]":"pos[-var[j]]":"var2[-var[j]]]=chr_of_origin[-var[j]]"-r"; replacement[chr_of_origin[-var[j]]":"pos[-var[j]]":"var1[-var[j]]]=chr_of_origin[-var[j]]"-a";
}
}
}
}
# read in the sam
($3 in replacement){for(i=12;i<=NF;i++){if($i~/^rt:A:/){rt=substr($i,6);break;}};print $1"\t"replacement[$3]"\t"rt}
EOD
) $1 $2
}

export -f doit

##	GNU Parallel Dependency
parallel="false"
if hash parallel 2>/dev/null; then
        ver=`parallel --version | awk 'NR==1{print \$3}'`
        [ $ver -ge 20150322 ] && parallel="true"
fi

[ $parallel == "false" ] && echo >&2 ":| WARNING: GNU Parallel version 20150322 or later not installed. We highly recommend to install it to increase performance. Starting pipeline without parallelization!"

[ $parallel == "true" ] && parallel -a $2 --pipepart -j ${threads} --will-cite --block 1G --env doit "doit $1 -" > $outfile || doit $1 $2 >$outfile